package at.asitplus.signum.indispensable.pki.attestation

import at.asitplus.KmmResult
import at.asitplus.catching
import at.asitplus.catchingUnwrapped
import at.asitplus.signum.indispensable.asn1.*
import at.asitplus.signum.indispensable.asn1.encoding.*
import at.asitplus.signum.indispensable.misc.BitLength
import kotlin.time.Instant
import kotlinx.datetime.Month
import kotlinx.datetime.number
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

/**
 * #### Intro
 * Authorization List ASN.1 sequence as [defined by Google](https://source.android.com/docs/security/features/keystore/attestation#schema).
 * Enum values as in the [keymint definitions](https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/)
 * This is the meat of the [AttestationKeyDescription] attestation certificate extension.
 * It is also used for secure key import.
 *
 * Every value is nullable because two authorization lists are present in an attestation extension:
 * once for software-enforced values, and once for hardware-enforced value.
 * The actual values are scattered across both instances.
 *
 * #### On Parsing
 * **Parsing is lenient:** If a value fails to parse, it is set to null. In reality,
 * you won't care whether a value is structurally illegal or absent:
 * * If you want to enforce it, it must be present and structurally valid, fulfilling your constraints
 * * If you don't care for it, you don't care whether it is present, invalid, or absent altogether
 * In case you still want to explore the raw value, check the raw ASN.1 Sequence from the certificate extension and fetch
 * the raw value according to the explicit tag denoting said value.
 *
 * #### Structural Properties and Design Decisions
 * **Structurally, this data structure follows the ASN.1 schema _exactly_**, meaning that it is a structural 1:1 mapping
 * if the underlying ASN.1 structure.
 * This as both advantages and disadvantages. The main disadvantage is that it is a bit cumbersome to use. The benefits
 * far outweigh the shortcomings of this approach, though:
 * * Just check the schema, and you know what's what. That means that there are no booleans, but an object indicating
 * `true` or `false` is either present or absent
 * * Re-Encoding produces the exact same ASN.1 structure that was parsed, byte-for-byte!
 * * Creating Attestation statements for testing, fun, profit, or malicious intentions is a peak no-brainer;
 * just follow the schema and set values!
 *
 * #### Closing Remarks
 * Note that values found in header files as the one below are conform with (autogenerated from?) the aidl files
 * https://android.googlesource.com/platform/hardware/libhardware/+/refs/heads/main/include_all/hardware/keymaster_defs.h
 *
 * Also note that some online sources do not match the specified ASN.1 values (in the following one PKCS7 has value 65 instead of 64)
 * https://android.googlesource.com/platform/frameworks/base/+blame/45ff13e/core/java/android/security/keymaster/KeymasterDefs.java
 */
class AuthorizationList(
    // @formatter:off
    val purpose                     : Set<KmmResult<KeyPurpose>>?             = null,
    val algorithm                   : KmmResult<Algorithm>?                   = null,
    val keySize                     : KmmResult<KeySize>?                     = null,
    val digest                      : Set<KmmResult<Digest>>?                 = null,
    val padding                     : Set<KmmResult<Padding>>?                = null,
    val ecCurve                     : KmmResult<ECCurve>?                     = null,
    val rsaPublicExponent           : KmmResult<RsaPublicExponent>?           = null,
    val mgfDigest                   : Set<KmmResult<MgfDigest>>?              = null,
    val rollbackResistance          : KmmResult<RollbackResistance>?          = null,
    val earlyBootOnly               : KmmResult<EarlyBootOnly>?               = null,
    val activeDateTime              : KmmResult<ActiveDateTime>?              = null,
    val originationExpireDateTime   : KmmResult<OriginationExpireDateTime>?   = null,
    val usageExpireDateTime         : KmmResult<UsageExpireDateTime>?         = null,
    val usageCountLimit             : KmmResult<UsageCountLimit>?             = null,
    val noAuthRequired              : KmmResult<NoAuthRequired>?              = null,
    val userAuthType                : KmmResult<UserAuthType>?                = null, // TODO: implemented as list of enums as in reference implementation
    val authTimeout                 : KmmResult<AuthTimeout>?                 = null,
    val allowWhileOnBody            : KmmResult<AllowWhileOnBody>?            = null,
    val trustedUserPresenceRequired : KmmResult<TrustedUserPresenceRequired>? = null,
    val trustedConfirmationRequired : KmmResult<TrustedConfirmationRequired>? = null,
    val unlockedDeviceRequired      : KmmResult<UnlockedDeviceRequired>?      = null,
    val allApplications             : KmmResult<AllApplications>?             = null, // only up to version v4 // TODO add opt-in annotation?
    val creationDateTime            : KmmResult<CreationDateTime>?            = null,
    val origin                      : KmmResult<Origin>?                      = null,
    val rollbackResistant           : KmmResult<RollbackResistent>?           = null, // only up to version v2, "resistance" afterwards // TODO add opt-in annotation?
    val rootOfTrust                 : KmmResult<RootOfTrust>?                 = null,
    val osVersion                   : KmmResult<OsVersion>?                   = null,
    val osPatchLevel                : KmmResult<OsPatchLevel>?                = null,
    val attestationApplicationId    : KmmResult<AttestationApplicationId>?    = null,
    val attestationIdBrand          : KmmResult<AttestationId.Brand>?         = null,
    val attestationIdDevice         : KmmResult<AttestationId.Device>?        = null,
    val attestationIdProduct        : KmmResult<AttestationId.Product>?       = null,
    val attestationIdSerial         : KmmResult<AttestationId.Serial>?        = null,
    val attestationIdImei           : KmmResult<AttestationId.Imei>?          = null,
    val attestationIdMeid           : KmmResult<AttestationId.Meid>?          = null,
    val attestationIdManufacturer   : KmmResult<AttestationId.Manufacturer>?  = null,
    val attestationIdModel          : KmmResult<AttestationId.Model>?         = null,
    val vendorPatchLevel            : KmmResult<PatchLevel.Vendor>?           = null,
    val bootPatchLevel              : KmmResult<PatchLevel.Boot>?             = null,
    val deviceUniqueAttestation     : KmmResult<DeviceUniqueAttestation>?     = null,
    val attestationIdSecondImei     : KmmResult<AttestationId.SecondImei>?    = null,
    val moduleHash                  : KmmResult<ModuleHash>?                  = null,
    // @formatter:on
    val attestationVersion: Int? = null,
) : Asn1Encodable<Asn1Sequence> {
    constructor(
        // @formatter:off
        purpose                     : Set<KeyPurpose>?             = null,
        algorithm                   : Algorithm?                   = null,
        keySize                     : KeySize?                     = null,
        digest                      : Set<Digest>?                 = null,
        padding                     : Set<Padding>?                = null,
        ecCurve                     : ECCurve?                     = null,
        rsaPublicExponent           : RsaPublicExponent?           = null,
        mgfDigest                   : Set<MgfDigest>?              = null,
        rollbackResistance          : RollbackResistance?          = null,
        earlyBootOnly               : EarlyBootOnly?               = null,
        activeDateTime              : ActiveDateTime?              = null,
        originationExpireDateTime   : OriginationExpireDateTime?   = null,
        usageExpireDateTime         : UsageExpireDateTime?         = null,
        usageCountLimit             : UsageCountLimit?             = null,
        noAuthRequired              : NoAuthRequired?              = null,
        userAuthType                : UserAuthType?                = null,
        authTimeout                 : AuthTimeout?                 = null,
        allowWhileOnBody            : AllowWhileOnBody?            = null,
        trustedUserPresenceRequired : TrustedUserPresenceRequired? = null,
        trustedConfirmationRequired : TrustedConfirmationRequired? = null,
        unlockedDeviceRequired      : UnlockedDeviceRequired?      = null,
        allApplications             : AllApplications?             = null,
        creationDateTime            : CreationDateTime?            = null,
        origin                      : Origin?                      = null,
        rollbackResistent           : RollbackResistent?           = null,
        rootOfTrust                 : RootOfTrust?                 = null,
        osVersion                   : OsVersion?                   = null,
        osPatchLevel                : OsPatchLevel?                = null,
        attestationApplicationId    : AttestationApplicationId?    = null,
        attestationIdBrand          : AttestationId.Brand?         = null,
        attestationIdDevice         : AttestationId.Device?        = null,
        attestationIdProduct        : AttestationId.Product?       = null,
        attestationIdSerial         : AttestationId.Serial?        = null,
        attestationIdImei           : AttestationId.Imei?          = null,
        attestationIdMeid           : AttestationId.Meid?          = null,
        attestationIdManufacturer   : AttestationId.Manufacturer?  = null,
        attestationIdModel          : AttestationId.Model?         = null,
        vendorPatchLevel            : PatchLevel.Vendor?           = null,
        bootPatchLevel              : PatchLevel.Boot?             = null,
        deviceUniqueAttestation     : DeviceUniqueAttestation?     = null,
        attestationIdSecondImei     : AttestationId.SecondImei?    = null,
        moduleHash                  : ModuleHash?                  = null,
        // @formatter:on
        attestationVersion: Int? = null,
    ) : this(
        // @formatter:off
        purpose                     = purpose                    ?.map { KmmResult.success(it) }?.toSet(),
        algorithm                   = algorithm                  ?.let { KmmResult.success(it) },
        keySize                     = keySize                    ?.let { KmmResult.success(it) },
        digest                      = digest                     ?.map { KmmResult.success(it) }?.toSet(),
        padding                     = padding                    ?.map { KmmResult.success(it) }?.toSet(),
        ecCurve                     = ecCurve                    ?.let { KmmResult.success(it) },
        rsaPublicExponent           = rsaPublicExponent          ?.let { KmmResult.success(it) },
        mgfDigest                   = mgfDigest                  ?.map { KmmResult.success(it) }?.toSet(),
        rollbackResistance          = rollbackResistance         ?.let { KmmResult.success(it) },
        earlyBootOnly               = earlyBootOnly              ?.let { KmmResult.success(it) },
        activeDateTime              = activeDateTime             ?.let { KmmResult.success(it) },
        originationExpireDateTime   = originationExpireDateTime  ?.let { KmmResult.success(it) },
        usageExpireDateTime         = usageExpireDateTime        ?.let { KmmResult.success(it) },
        usageCountLimit             = usageCountLimit            ?.let { KmmResult.success(it) },
        noAuthRequired              = noAuthRequired             ?.let { KmmResult.success(it) },
        userAuthType                = userAuthType               ?.let { KmmResult.success(it) },
        authTimeout                 = authTimeout                ?.let { KmmResult.success(it) },
        allowWhileOnBody            = allowWhileOnBody           ?.let { KmmResult.success(it) },
        trustedUserPresenceRequired = trustedUserPresenceRequired?.let { KmmResult.success(it) },
        trustedConfirmationRequired = trustedConfirmationRequired?.let { KmmResult.success(it) },
        unlockedDeviceRequired      = unlockedDeviceRequired     ?.let { KmmResult.success(it) },
        allApplications             = allApplications            ?.let { KmmResult.success(it) },
        creationDateTime            = creationDateTime           ?.let { KmmResult.success(it) },
        origin                      = origin                     ?.let { KmmResult.success(it) },
        rollbackResistant           = rollbackResistent          ?.let { KmmResult.success(it) },
        rootOfTrust                 = rootOfTrust                ?.let { KmmResult.success(it) },
        osVersion                   = osVersion                  ?.let { KmmResult.success(it) },
        osPatchLevel                = osPatchLevel               ?.let { KmmResult.success(it) },
        attestationApplicationId    = attestationApplicationId   ?.let { KmmResult.success(it) },
        attestationIdBrand          = attestationIdBrand         ?.let { KmmResult.success(it) },
        attestationIdDevice         = attestationIdDevice        ?.let { KmmResult.success(it) },
        attestationIdProduct        = attestationIdProduct       ?.let { KmmResult.success(it) },
        attestationIdSerial         = attestationIdSerial        ?.let { KmmResult.success(it) },
        attestationIdImei           = attestationIdImei          ?.let { KmmResult.success(it) },
        attestationIdMeid           = attestationIdMeid          ?.let { KmmResult.success(it) },
        attestationIdManufacturer   = attestationIdManufacturer  ?.let { KmmResult.success(it) },
        attestationIdModel          = attestationIdModel         ?.let { KmmResult.success(it) },
        vendorPatchLevel            = vendorPatchLevel           ?.let { KmmResult.success(it) },
        bootPatchLevel              = bootPatchLevel             ?.let { KmmResult.success(it) },
        deviceUniqueAttestation     = deviceUniqueAttestation    ?.let { KmmResult.success(it) },
        attestationIdSecondImei     = attestationIdSecondImei    ?.let { KmmResult.success(it) },
        moduleHash                  = moduleHash                 ?.let { KmmResult.success(it) },
        // @formatter:on
        attestationVersion,
    )

    init {
        purpose?.let { require(it.isNotEmpty()) }
        digest?.let { require(it.isNotEmpty()) }
        padding?.let { require(it.isNotEmpty()) }
        mgfDigest?.let { require(it.isNotEmpty()) }

        versionCheck()
    }

    fun versionCheck() {
        if (attestationVersion != null) {
            if (attestationVersion < 400) {
                require(moduleHash == null)
            }
            if (attestationVersion < 300) {
                require(attestationIdSecondImei == null)
            }
            // no changes from 100 to 200
            if (attestationVersion < 100) {
                require(mgfDigest == null) // isNullOrEmpty ? TODO
                require(usageCountLimit == null)
            }
            if (attestationVersion > 4) {
                require(allApplications == null)
            }
            if (attestationVersion < 4) {
                require(earlyBootOnly == null)
                require(deviceUniqueAttestation == null)
            }
            if (attestationVersion < 3) {
                require(rollbackResistance == null)
                require(trustedUserPresenceRequired == null)
                require(trustedConfirmationRequired == null)
                require(unlockedDeviceRequired == null)
                require(vendorPatchLevel == null)
                require(bootPatchLevel == null)
                //if(rootOfTrust != null) require(rootOfTrust.getOrNull().verifiedBootHash == 0) // TODO decoding must be changed!!
            }
            if (attestationVersion > 2) {
                require(rollbackResistant == null)
            }
            if (attestationVersion < 2) {
                require(attestationApplicationId == null)
                require(attestationIdBrand == null)
                require(attestationIdDevice == null)
                require(attestationIdProduct == null)
                require(attestationIdSerial == null)
                require(attestationIdImei == null)
                require(attestationIdMeid == null)
                require(attestationIdManufacturer == null)
                require(attestationIdModel == null)
            }
        }
        // TODO: only provide getter in right versions?
    }

    override fun encodeToTlv() = Asn1.Sequence {
        // @formatter:off
        add(purpose?.mapNotNull{it.getOrNull()}?.toSet()) // TODO error handling instead of getOrNull?
        add(algorithm                  ?.getOrNull())
        add(keySize                    ?.getOrNull())
        add(digest?.mapNotNull{it.getOrNull()}?.toSet())
        add(padding?.mapNotNull{it.getOrNull()}?.toSet())
        add(ecCurve                    ?.getOrNull())
        add(rsaPublicExponent          ?.getOrNull())
        add(mgfDigest?.mapNotNull{it.getOrNull()}?.toSet())
        add(rollbackResistance         ?.getOrNull())
        add(earlyBootOnly              ?.getOrNull())
        add(activeDateTime             ?.getOrNull())
        add(originationExpireDateTime  ?.getOrNull())
        add(usageExpireDateTime        ?.getOrNull())
        add(usageCountLimit            ?.getOrNull())
        add(noAuthRequired             ?.getOrNull())
        add(userAuthType               ?.getOrNull())
        add(authTimeout                ?.getOrNull())
        add(allowWhileOnBody           ?.getOrNull())
        add(trustedUserPresenceRequired?.getOrNull())
        add(trustedConfirmationRequired?.getOrNull())
        add(unlockedDeviceRequired     ?.getOrNull())
        add(allApplications            ?.getOrNull())
        add(creationDateTime           ?.getOrNull())
        add(origin                     ?.getOrNull())
        add(rollbackResistant          ?.getOrNull())
        add(rootOfTrust                ?.getOrNull())
        add(osVersion                  ?.getOrNull())
        add(osPatchLevel               ?.getOrNull())
        // @formatter:on

        // attestationApplicationId is encoded as OctetString
        val appId = attestationApplicationId?.getOrNull()
        appId?.let {
            +Asn1.ExplicitlyTagged(appId.tagged.explicitTag) {
                +Asn1.OctetStringEncapsulating {
                    +appId.encodeToTlv()
                }
            }
        }

        // @formatter:off
        add(attestationIdBrand       ?.getOrNull())
        add(attestationIdDevice      ?.getOrNull())
        add(attestationIdProduct     ?.getOrNull())
        add(attestationIdSerial      ?.getOrNull())
        add(attestationIdImei        ?.getOrNull())
        add(attestationIdMeid        ?.getOrNull())
        add(attestationIdManufacturer?.getOrNull())
        add(attestationIdModel       ?.getOrNull())
        add(vendorPatchLevel         ?.getOrNull())
        add(bootPatchLevel           ?.getOrNull())
        add(deviceUniqueAttestation  ?.getOrNull())
        add(attestationIdSecondImei  ?.getOrNull())
        add(moduleHash               ?.getOrNull())
        // @formatter:on
    }

    companion object : Asn1Decodable<Asn1Sequence, AuthorizationList> {
        override fun doDecode(src: Asn1Sequence): AuthorizationList {
            // @formatter:off
            val purpose                    : Set<KmmResult<KeyPurpose>>?             = KeyPurpose.decodeSet(src)
            val algorithm                  : KmmResult<Algorithm>?                   = Algorithm.decode(src)
            val keySize                    : KmmResult<KeySize>?                     = KeySize.decode(src)
            val digest                     : Set<KmmResult<Digest>>?                 = Digest.decodeSet(src)
            val padding                    : Set<KmmResult<Padding>>?                = Padding.decodeSet(src)
            val ecCurve                    : KmmResult<ECCurve>?                     = ECCurve.decode(src)
            val rsaPublicExponent          : KmmResult<RsaPublicExponent>?           = RsaPublicExponent.decode(src)
            val mgfDigest                  : Set<KmmResult<MgfDigest>>?              = MgfDigest.decodeSet(src)
            val rollbackResistance         : KmmResult<RollbackResistance>?          = RollbackResistance.decodeNull(src)
            val earlyBootOnly              : KmmResult<EarlyBootOnly>?               = EarlyBootOnly.decodeNull(src)
            val activeDateTime             : KmmResult<ActiveDateTime>?              = ActiveDateTime.decode(src)
            val originationExpireDateTime  : KmmResult<OriginationExpireDateTime>?   = OriginationExpireDateTime.decode(src)
            val usageExpireDateTime        : KmmResult<UsageExpireDateTime>?         = UsageExpireDateTime.decode(src)
            val usageCountLimit            : KmmResult<UsageCountLimit>?             = UsageCountLimit.decode(src)
            val noAuthRequired             : KmmResult<NoAuthRequired>?              = NoAuthRequired.decodeNull(src)
            val userAuthType               : KmmResult<UserAuthType>?                = UserAuthType.decode(src)
            val authTimeout                : KmmResult<AuthTimeout>?                 = AuthTimeout.decode(src)
            val allowWhileOnBody           : KmmResult<AllowWhileOnBody>?            = AllowWhileOnBody.decodeNull(src)
            val trustedUserPresenceRequired: KmmResult<TrustedUserPresenceRequired>? = TrustedUserPresenceRequired.decodeNull(src)
            val trustedConfirmationRequired: KmmResult<TrustedConfirmationRequired>? = TrustedConfirmationRequired.decodeNull(src)
            val unlockedDeviceRequired     : KmmResult<UnlockedDeviceRequired>?      = UnlockedDeviceRequired.decodeNull(src)
            val allApplications            : KmmResult<AllApplications>?             = AllApplications.decodeNull(src)
            val creationDateTime           : KmmResult<CreationDateTime>?            = CreationDateTime.decode(src)
            val origin                     : KmmResult<Origin>?                      = Origin.decode(src)
            val rollbackResistent          : KmmResult<RollbackResistent>?           = RollbackResistent.decodeNull(src)
            // @formatter:on

            val rootOfTrust: KmmResult<RootOfTrust>? =
                src[RootOfTrust.explicitTag]?.let { RootOfTrust.decodeFromTlvSafe(it.asSequence()) }
            val osVersion: KmmResult<OsVersion>? = OsVersion.decode(src)
            val osPatchLevel: KmmResult<OsPatchLevel>? = OsPatchLevel.decode(src)

            val attestationApplicationId: KmmResult<AttestationApplicationId>? =
                src[AttestationApplicationId.explicitTag]?.let {
                    catching {
                        val children = it.asEncapsulatingOctetString().children
                        require(children.size == 1) // TODO: check again, and also check others TLV entries so that at most 1 is given, should we give a warning? not lenient
                        AttestationApplicationId.decodeFromTlv(children.first().asSequence())
                    }
                }

            // @formatter:off
            val attestationIdBrand       : KmmResult<AttestationId.Brand>?          = AttestationId.Brand.decode(src)
            val attestationIdDevice      : KmmResult<AttestationId.Device>?         = AttestationId.Device.decode(src)
            val attestationIdProduct     : KmmResult<AttestationId.Product>?        = AttestationId.Product.decode(src)
            val attestationIdSerial      : KmmResult<AttestationId.Serial>?         = AttestationId.Serial.decode(src)
            val attestationIdImei        : KmmResult<AttestationId.Imei>?           = AttestationId.Imei.decode(src)
            val attestationIdMeid        : KmmResult<AttestationId.Meid>?           = AttestationId.Meid.decode(src)
            val attestationIdManufacturer: KmmResult<AttestationId.Manufacturer>?   = AttestationId.Manufacturer.decode(src)
            val attestationIdModel       : KmmResult<AttestationId.Model>?          = AttestationId.Model.decode(src)
            val vendorPatchLevel         : KmmResult<PatchLevel.Vendor>?            = PatchLevel.Vendor.decode(src)
            val bootPatchLevel           : KmmResult<PatchLevel.Boot>?              = PatchLevel.Boot.decode(src)
            val deviceUniqueAttestation  : KmmResult<DeviceUniqueAttestation>?      = DeviceUniqueAttestation.decodeNull(src)
            val attestationIdSecondImei  : KmmResult<AttestationId.SecondImei>?     = AttestationId.SecondImei.decode(src)
            val moduleHash               : KmmResult<ModuleHash>?                   = ModuleHash.decode(src)
            // @formatter:on

            return AuthorizationList(
                purpose,
                algorithm,
                keySize,
                digest,
                padding,
                ecCurve,
                rsaPublicExponent,
                mgfDigest,
                rollbackResistance,
                earlyBootOnly,
                activeDateTime,
                originationExpireDateTime,
                usageExpireDateTime,
                usageCountLimit,
                noAuthRequired,
                userAuthType,
                authTimeout,
                allowWhileOnBody,
                trustedUserPresenceRequired,
                trustedConfirmationRequired,
                unlockedDeviceRequired,
                allApplications,
                creationDateTime,
                origin,
                rollbackResistent,
                rootOfTrust,
                osVersion,
                osPatchLevel,
                attestationApplicationId,
                attestationIdBrand,
                attestationIdDevice,
                attestationIdProduct,
                attestationIdSerial,
                attestationIdImei,
                attestationIdMeid,
                attestationIdManufacturer,
                attestationIdModel,
                vendorPatchLevel,
                bootPatchLevel,
                deviceUniqueAttestation,
                attestationIdSecondImei,
                moduleHash,
                // TODO: attestationVersion!
            )
        }


        // TODO: check decode functions once more
        private inline fun <reified T : Tagged, reified D : Asn1Encodable<Asn1Element>> T.decode(src: Asn1Sequence): KmmResult<D>? =
            src[explicitTag]?.let {
                @Suppress("UNCHECKED_CAST")
                (this as Asn1Decodable<Asn1Element, D>).decodeFromTlvSafe(src = it)
            }

        private inline fun <reified T : Tagged, reified D : Asn1Encodable<Asn1Element>> T.decodeSet(
            src: Asn1Sequence
        ): Set<KmmResult<D>>? = src[explicitTag]?.let {
            @Suppress("UNCHECKED_CAST")
            (it as Asn1Set).children.mapNotNull {
                (this as Asn1Decodable<Asn1Element, D>).decodeFromTlvSafe(
                    it.asPrimitive()
                )
            }.toSet()
                .let { if (it.isEmpty()) null else it } // TODO isEmpty -> null? << do we really want null instead of empty sets? rather use empty set
        }

        private inline fun <reified T : Tagged, reified D : Asn1Encodable<Asn1Element>> T.decodeSequence(
            src: Asn1Sequence
        ): List<KmmResult<D>>? = src[explicitTag]?.let {
            @Suppress("UNCHECKED_CAST")
            (it as Asn1Sequence).children.mapNotNull {
                (this as Asn1Decodable<Asn1Element, D>).decodeFromTlvSafe(
                    it.asPrimitive()
                )
            }.toList().let { if (it.isEmpty()) null else it }
        }

        private operator fun Asn1Sequence.get(tag: ULong): Asn1Element? {
            val asn1Tag = Asn1.ExplicitTag(tag)
            return ((children.firstOrNull { (it as Asn1ExplicitlyTagged).tag == asn1Tag } as Asn1ExplicitlyTagged?)?.children)?.singleOrNull
        }

        private inline fun <reified T : Tagged> T.decodeNull_(src: Asn1Sequence): T? =
            if (src.hasNull(explicitTag)) this else null

        private inline fun <reified T : Tagged> T.decodeNull(src: Asn1Sequence): KmmResult<T>? =
            if (src.hasNull(explicitTag)) KmmResult.success(this) else null

        private fun Asn1Sequence.hasNull(tag: ULong): Boolean {
            val asn1Tag = Asn1.ExplicitTag(tag)
            return ((children.firstOrNull { (it as Asn1ExplicitlyTagged).tag == asn1Tag } as Asn1ExplicitlyTagged?)?.children)?.let {
                if (it.size != 1) false
                else catchingUnwrapped { it.first().asPrimitive().readNull() }
                    .fold(onSuccess = { true }, onFailure = { false })
            } ?: false
        }

        private val List<Asn1Element>.singleOrNull: Asn1Element? get() = if (size == 1) first() else null
    }

    private fun Asn1TreeBuilder.add(element: Set<Tagged.WithTag<*>>?) {
        element?.let { +it.encode() }
    }

    private fun Asn1TreeBuilder.add(element: Tagged.WithTag<*>?) {
        element?.let { +Asn1.ExplicitlyTagged(it.tagged.explicitTag) { +it.encodeToTlv() } }
    }

    private fun Asn1TreeBuilder.add(element: Tagged?) {
        element?.let { +Asn1.ExplicitlyTagged(it.explicitTag) { +Asn1.Null() } }
    }

    private val Set<Tagged.WithTag<*>>.explicitTag get() = first().tagged.explicitTag
    private fun Set<Tagged.WithTag<*>>.encode() = Asn1.ExplicitlyTagged(explicitTag) {
        +Asn1.SetOf { forEach { +it } }

    }


    @OptIn(ExperimentalStdlibApi::class)
    override fun toString(): String {
        return "AuthorizationList(" +
                "purpose=$purpose, " +
                "algorithm=$algorithm, " +
                "keySize=$keySize, " +
                "digest=$digest, " +
                "padding=$padding, " +
                "ecCurve=$ecCurve, " +
                "rsaPublicExponent=$rsaPublicExponent, " +
                "mgfDigest=$mgfDigest, " +
                "rollbackResistance=${rollbackResistance != null}, " +
                "earlyBootOnly=${earlyBootOnly != null}, " +
                "activeDateTime=$activeDateTime, " +
                "originationExpireDateTime=$originationExpireDateTime, " +
                "usageExpireDateTime=$usageExpireDateTime, " +
                "usageCountLimit=$usageCountLimit, " +
                "noAuthRequired=${noAuthRequired != null}, " +
                "userAuthType=$userAuthType, " +
                "authTimeout=$authTimeout, " +
                "allowWhileOnBody=${allowWhileOnBody != null}, " +
                "trustedUserPresenceRequired=${trustedUserPresenceRequired != null}, " +
                "trustedConfirmationRequired=${trustedConfirmationRequired != null}, " +
                "unlockedDeviceRequired=${unlockedDeviceRequired != null}, " +
                "allApplications=${allApplications != null}, " +
                "creationDateTime=$creationDateTime, " +
                "origin=$origin, " +
                "rollbackResistent=$rollbackResistant, " +
                "rootOfTrust=$rootOfTrust, " +
                "osVersion=$osVersion, " +
                "osPatchLevel=$osPatchLevel, " +
                "attestationApplicationId=$attestationApplicationId, " +
                "attestationIdBrand=$attestationIdBrand, " +
                "attestationIdDevice=$attestationIdDevice, " +
                "attestationIdProduct=$attestationIdProduct, " +
                "attestationIdSerial=$attestationIdSerial, " +
                "attestationIdImei=$attestationIdImei, " +
                "attestationIdMeid=$attestationIdMeid, " +
                "attestationIdManufacturer=$attestationIdManufacturer, " +
                "attestationIdModel=$attestationIdModel, " +
                "vendorPatchLevel=$vendorPatchLevel, " +
                "bootPatchLevel=$bootPatchLevel, " +
                "deviceUniqueAttestation=${deviceUniqueAttestation != null}, " +
                "attestationIdSecondImei=$attestationIdSecondImei, " +
                "moduleHash=$moduleHash" +
                ")"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is AuthorizationList) return false

        if (purpose != other.purpose) return false
        if (algorithm != other.algorithm) return false
        if (keySize != other.keySize) return false
        if (digest != other.digest) return false
        if (padding != other.padding) return false
        if (ecCurve != other.ecCurve) return false
        if (rsaPublicExponent != other.rsaPublicExponent) return false
        if (mgfDigest != other.mgfDigest) return false
        if (rollbackResistance != other.rollbackResistance) return false
        if (earlyBootOnly != other.earlyBootOnly) return false
        if (activeDateTime != other.activeDateTime) return false
        if (originationExpireDateTime != other.originationExpireDateTime) return false
        if (usageExpireDateTime != other.usageExpireDateTime) return false
        if (usageCountLimit != other.usageCountLimit) return false
        if (noAuthRequired != other.noAuthRequired) return false
        if (userAuthType != other.userAuthType) return false
        if (authTimeout != other.authTimeout) return false
        if (allowWhileOnBody != other.allowWhileOnBody) return false
        if (trustedUserPresenceRequired != other.trustedUserPresenceRequired) return false
        if (trustedConfirmationRequired != other.trustedConfirmationRequired) return false
        if (unlockedDeviceRequired != other.unlockedDeviceRequired) return false
        if (allApplications != other.allApplications) return false
        if (creationDateTime != other.creationDateTime) return false
        if (origin != other.origin) return false
        if (rollbackResistant != other.rollbackResistant) return false
        if (rootOfTrust != other.rootOfTrust) return false
        if (osVersion != other.osVersion) return false
        if (osPatchLevel != other.osPatchLevel) return false
        if (attestationApplicationId != other.attestationApplicationId) return false
        if (attestationIdBrand != other.attestationIdBrand) return false
        if (attestationIdDevice != other.attestationIdDevice) return false
        if (attestationIdProduct != other.attestationIdProduct) return false
        if (attestationIdSerial != other.attestationIdSerial) return false
        if (attestationIdImei != other.attestationIdImei) return false
        if (attestationIdMeid != other.attestationIdMeid) return false
        if (attestationIdManufacturer != other.attestationIdManufacturer) return false
        if (attestationIdModel != other.attestationIdModel) return false
        if (vendorPatchLevel != other.vendorPatchLevel) return false
        if (bootPatchLevel != other.bootPatchLevel) return false
        if (deviceUniqueAttestation != other.deviceUniqueAttestation) return false
        if (attestationIdSecondImei != other.attestationIdSecondImei) return false
        if (moduleHash != other.moduleHash) return false

        return true
    }

    override fun hashCode(): Int {
        var result = purpose?.hashCode() ?: 0
        result = 31 * result + (algorithm?.hashCode() ?: 0)
        result = 31 * result + (keySize?.hashCode() ?: 0)
        result = 31 * result + (digest?.hashCode() ?: 0)
        result = 31 * result + (padding?.hashCode() ?: 0)
        result = 31 * result + (ecCurve?.hashCode() ?: 0)
        result = 31 * result + (rsaPublicExponent?.hashCode() ?: 0)
        result = 31 * result + (mgfDigest?.hashCode() ?: 0)
        result = 31 * result + (rollbackResistance?.hashCode() ?: 0)
        result = 31 * result + (earlyBootOnly?.hashCode() ?: 0)
        result = 31 * result + (activeDateTime?.hashCode() ?: 0)
        result = 31 * result + (originationExpireDateTime?.hashCode() ?: 0)
        result = 31 * result + (usageExpireDateTime?.hashCode() ?: 0)
        result = 31 * result + (usageCountLimit?.hashCode() ?: 0)
        result = 31 * result + (noAuthRequired?.hashCode() ?: 0)
        result = 31 * result + (userAuthType?.hashCode() ?: 0)
        result = 31 * result + (authTimeout?.hashCode() ?: 0)
        result = 31 * result + (allowWhileOnBody?.hashCode() ?: 0)
        result = 31 * result + (trustedUserPresenceRequired?.hashCode() ?: 0)
        result = 31 * result + (trustedConfirmationRequired?.hashCode() ?: 0)
        result = 31 * result + (unlockedDeviceRequired?.hashCode() ?: 0)
        result = 31 * result + (allApplications?.hashCode() ?: 0)
        result = 31 * result + (creationDateTime?.hashCode() ?: 0)
        result = 31 * result + (origin?.hashCode() ?: 0)
        result = 31 * result + (rollbackResistant?.hashCode() ?: 0)
        result = 31 * result + (rootOfTrust?.hashCode() ?: 0)
        result = 31 * result + (osVersion?.hashCode() ?: 0)
        result = 31 * result + (osPatchLevel?.hashCode() ?: 0)
        result = 31 * result + (attestationApplicationId?.hashCode() ?: 0)
        result = 31 * result + (attestationIdBrand?.hashCode() ?: 0)
        result = 31 * result + (attestationIdDevice?.hashCode() ?: 0)
        result = 31 * result + (attestationIdProduct?.hashCode() ?: 0)
        result = 31 * result + (attestationIdSerial?.hashCode() ?: 0)
        result = 31 * result + (attestationIdImei?.hashCode() ?: 0)
        result = 31 * result + (attestationIdMeid?.hashCode() ?: 0)
        result = 31 * result + (attestationIdManufacturer?.hashCode() ?: 0)
        result = 31 * result + (attestationIdModel?.hashCode() ?: 0)
        result = 31 * result + (vendorPatchLevel?.hashCode() ?: 0)
        result = 31 * result + (bootPatchLevel?.hashCode() ?: 0)
        result = 31 * result + (deviceUniqueAttestation?.hashCode() ?: 0)
        result = 31 * result + (attestationIdSecondImei?.hashCode() ?: 0)
        result = 31 * result + (moduleHash?.hashCode() ?: 0)
        return result
    }

    interface IntEncodable : Asn1Encodable<Asn1Primitive>, Tagged.WithTag<Asn1Primitive> {
        val intValue: Asn1Integer

        override fun encodeToTlv() = intValue.encodeToTlv()
    }

    sealed class Tagged(val explicitTag: ULong) {
        sealed interface WithTag<A : Asn1Element> : Asn1Encodable<A> {
            val tagged: Tagged
        }
    }

    enum class KeyPurpose(override val intValue: Asn1Integer) : IntEncodable {
        ENCRYPT(Asn1Integer(0)),
        DECRYPT(Asn1Integer(1)),
        SIGN(Asn1Integer(2)),
        VERIFY(Asn1Integer(3)),
        DERIVE_KEY(Asn1Integer(4)), // according to aidl specification: "4 is reserved", note: not in reference implementation // TODO
        WRAP_KEY(Asn1Integer(5)),
        AGREE_KEY(Asn1Integer(6)),
        ATTEST_KEY(Asn1Integer(7));
        // From: https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/KeyPurpose.aidl

        companion object Tag : Tagged(1uL), Asn1Decodable<Asn1Primitive, KeyPurpose> {
            fun valueOf(int: Asn1Integer) = entries.first { it.intValue == int }
            override fun doDecode(src: Asn1Primitive) = valueOf(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    enum class Algorithm(override val intValue: Asn1Integer) : IntEncodable {
        RSA(Asn1Integer(1)),

        //@HazardousMaterials("according to aidl specification: removed, do not reuse.") DSA(Asn1Integer(2)), // TODO: comment in for BasicParsingTests to fail
        EC(Asn1Integer(3)),
        AES(Asn1Integer(32)),
        TRIPLE_DES(Asn1Integer(33)),
        HMAC(Asn1Integer(128));
        // From: https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/Algorithm.aidl

        companion object Tag : Tagged(2uL), Asn1Decodable<Asn1Primitive, Algorithm> {
            fun valueOf(int: Asn1Integer) = entries.first { it.intValue == int }
            override fun doDecode(src: Asn1Primitive) = valueOf(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    class KeySize private constructor(override val intValue: Asn1Integer) : IntEncodable {
        constructor(keyLength: BitLength) : this(Asn1Integer(keyLength.bits))

        companion object Tag : Tagged(3uL), Asn1Decodable<Asn1Primitive, KeySize> {
            override fun doDecode(src: Asn1Primitive) = KeySize(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
        override fun toString(): String {
            return "KeySize(intValue=$intValue)"
        }
    }

    enum class Digest(override val intValue: Asn1Integer) : IntEncodable {
        NONE(Asn1Integer(0)),
        MD5(Asn1Integer(1)),
        SHA1(Asn1Integer(2)),
        SHA_2_224(Asn1Integer(3)),
        SHA_2_256(Asn1Integer(4)),
        SHA_2_384(Asn1Integer(5)),
        SHA_2_512(Asn1Integer(6));
        // From: https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/Digest.aidl

        companion object Tag : Tagged(5uL), Asn1Decodable<Asn1Primitive, Digest> {
            fun valueOf(int: Asn1Integer) = entries.first { it.intValue == int }
            override fun doDecode(src: Asn1Primitive) = valueOf(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    enum class Padding(override val intValue: Asn1Integer) : IntEncodable {
        NONE(Asn1Integer(1)),
        RSA_OAEP(Asn1Integer(2)),
        RSA_PSS(Asn1Integer(3)),
        RSA_PKCS1_1_5_ENCRYPT(Asn1Integer(4)),
        RSA_PKCS1_1_5_SIGN(Asn1Integer(5)),
        PKCS7(Asn1Integer(64));
        // From: https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/PaddingMode.aidl

        companion object Tag : Tagged(6uL), Asn1Decodable<Asn1Primitive, Padding> {
            fun valueOf(int: Asn1Integer) = entries.first { it.intValue == int }
            override fun doDecode(src: Asn1Primitive) = valueOf(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }


    enum class ECCurve(override val intValue: Asn1Integer) : IntEncodable {
        P_224(Asn1Integer(0)),
        P_256(Asn1Integer(1)),
        P_384(Asn1Integer(2)),
        P_521(Asn1Integer(3)),
        CURVE_25519(Asn1Integer(4));
        // From: https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/EcCurve.aidl

        companion object Tag : Tagged(10uL), Asn1Decodable<Asn1Primitive, ECCurve> {
            fun valueOf(int: Asn1Integer) = entries.first { it.intValue == int }
            override fun doDecode(src: Asn1Primitive) = valueOf(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    class RsaPublicExponent private constructor(override val intValue: Asn1Integer) : IntEncodable {
        constructor(exponent: Asn1Integer.Positive) : this(intValue = exponent)

        companion object Tag : Tagged(200uL), Asn1Decodable<Asn1Primitive, RsaPublicExponent> {
            override fun doDecode(src: Asn1Primitive) = RsaPublicExponent(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    // TODO set of integers
    //MGF digest is undocumented. tough luck my friend!
    class MgfDigest(override val intValue: Asn1Integer) : IntEncodable {
        companion object Tag : Tagged(203uL), Asn1Decodable<Asn1Primitive, MgfDigest> {
            override fun doDecode(src: Asn1Primitive) = MgfDigest(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    object RollbackResistance : Tagged(303uL) {
    }

    object EarlyBootOnly : Tagged(305uL) {
    }

    class ActiveDateTime private constructor(override val intValue: Asn1Integer) : IntEncodable {
        constructor(notBefore: Instant) : this(Asn1Integer(notBefore.toEpochMilliseconds()))

        companion object Tag : Tagged(400uL), Asn1Decodable<Asn1Primitive, ActiveDateTime> {
            override fun doDecode(src: Asn1Primitive) = ActiveDateTime(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    class OriginationExpireDateTime private constructor(override val intValue: Asn1Integer) :
        IntEncodable {
        constructor(notAfter: Instant) : this(Asn1Integer(notAfter.toEpochMilliseconds()))

        companion object Tag : Tagged(401uL),
            Asn1Decodable<Asn1Primitive, OriginationExpireDateTime> {
            override fun doDecode(src: Asn1Primitive) =
                OriginationExpireDateTime(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    class UsageExpireDateTime private constructor(override val intValue: Asn1Integer) :
        IntEncodable {
        constructor(notAfter: Instant) : this(Asn1Integer(notAfter.toEpochMilliseconds()))

        companion object Tag : Tagged(402uL), Asn1Decodable<Asn1Primitive, UsageCountLimit> {
            override fun doDecode(src: Asn1Primitive) = UsageCountLimit(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    class UsageCountLimit(override val intValue: Asn1Integer) : IntEncodable {
        companion object Tag : Tagged(405uL), Asn1Decodable<Asn1Primitive, UsageCountLimit> {
            override fun doDecode(src: Asn1Primitive) = UsageCountLimit(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    object NoAuthRequired : Tagged(503uL) {
    }

    enum class UserAuthType(override val intValue: Asn1Integer) : IntEncodable {
        NONE(Asn1Integer(0)),
        PASSWORD(Asn1Integer(1)),
        FINGERPRINT(Asn1Integer(2)),
        ANY(Asn1Integer(UInt.MAX_VALUE));
        // source: https://android.googlesource.com/platform/hardware/interfaces/+/refs/heads/main/keymaster/aidl/android/hardware/keymaster/HardwareAuthenticatorType.aidl

        companion object Tag : Tagged(504uL), Asn1Decodable<Asn1Primitive, UserAuthType> {
            fun valueOf(int: Asn1Integer) = entries.first { it.intValue == int }
            override fun doDecode(src: Asn1Primitive) = valueOf(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    class AuthTimeout private constructor(override val intValue: Asn1Integer) : IntEncodable {
        constructor(duration: Duration) : this(Asn1Integer(duration.inWholeSeconds))

        val duration: Duration =
            Long.decodeFromAsn1ContentBytes(intValue.encodeToAsn1ContentBytes()).seconds

        init {
            require(intValue.magnitude.size <= 4) // TODO: where is this specified?
        }

        companion object Tag : Tagged(505uL), Asn1Decodable<Asn1Primitive, AuthTimeout> {
            override fun doDecode(src: Asn1Primitive) = AuthTimeout(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
        override fun toString(): String {
            return "AuthTimeout(intValue=$intValue, duration=$duration)"
        }
    }

    object AllowWhileOnBody : Tagged(506uL)

    object TrustedUserPresenceRequired : Tagged(507uL)

    object TrustedConfirmationRequired : Tagged(508uL)

    object UnlockedDeviceRequired : Tagged(509uL)

    object AllApplications : Tagged(600uL)

    class CreationDateTime private constructor(override val intValue: Asn1Integer) : IntEncodable {
        constructor(timestamp: Instant) : this(Asn1Integer(timestamp.toEpochMilliseconds()))

        val timestamp: Instant =
            Instant.fromEpochMilliseconds(Long.decodeFromAsn1ContentBytes(intValue.encodeToAsn1ContentBytes()))

        companion object Tag : Tagged(701uL), Asn1Decodable<Asn1Primitive, CreationDateTime> {
            override fun doDecode(src: Asn1Primitive) = CreationDateTime(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
        override fun toString(): String {
            return "CreationDateTime(intValue=$intValue, timestamp=$timestamp)"
        }
    }

    enum class Origin(override val intValue: Asn1Integer) : IntEncodable {
        GENERATED(Asn1Integer(0)),
        DERIVED(Asn1Integer(1)),
        IMPORTED(Asn1Integer(2)),
        RESERVED(Asn1Integer(3)),
        SECURELY_IMPORTED(Asn1Integer(4));
        // From: https://cs.android.com/android/platform/superproject/main/+/main:hardware/interfaces/security/keymint/aidl/android/hardware/security/keymint/KeyOrigin.aidl

        companion object Tag : Tagged(702uL), Asn1Decodable<Asn1Primitive, Origin> {
            fun valueOf(int: Asn1Integer) = entries.first { it.intValue == int }
            override fun doDecode(src: Asn1Primitive) = valueOf(src.decodeToAsn1Integer())
        }

        override val tagged get() = Tag
    }

    object RollbackResistent : Tagged(703uL) {
    }

    class RootOfTrust(
        val verifiedBootKeyDigest: ByteArray,
        val deviceLocked: Boolean,
        val verifiedBootState: VerifiedBootState,
        val verifiedBootHash: ByteArray
    ) : Asn1Encodable<Asn1Sequence>, Tagged.WithTag<Asn1Sequence> {
        companion object Tag : Tagged(704uL), Asn1Decodable<Asn1Sequence, RootOfTrust> {
            override fun doDecode(src: Asn1Sequence) = src.iterator().run {
                RootOfTrust(
                    next().asPrimitive().content,
                    next().asPrimitive().decodeToBoolean(),
                    VerifiedBootState.decodeFromTlv(next().asPrimitive()),
                    next().asPrimitive().content
                )
            }
        }

        override val tagged get() = Tag

        override fun encodeToTlv() = Asn1.Sequence {
            +Asn1.OctetString(verifiedBootKeyDigest)
            +Asn1.Bool(deviceLocked)
            +verifiedBootState
            +Asn1.OctetString(verifiedBootHash)
        }

        @OptIn(ExperimentalStdlibApi::class)
        override fun toString(): String {
            return "RootOfTrust(verifiedBootKeyDigest=${verifiedBootKeyDigest.toHexString()}, deviceLocked=$deviceLocked, verifiedBootState=$verifiedBootState, verifiedBootHash=${verifiedBootHash.toHexString()})"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is RootOfTrust) return false

            if (deviceLocked != other.deviceLocked) return false
            if (!verifiedBootKeyDigest.contentEquals(other.verifiedBootKeyDigest)) return false
            if (verifiedBootState != other.verifiedBootState) return false
            if (!verifiedBootHash.contentEquals(other.verifiedBootHash)) return false

            return true
        }

        override fun hashCode(): Int {
            var result = deviceLocked.hashCode()
            result = 31 * result + verifiedBootKeyDigest.contentHashCode()
            result = 31 * result + verifiedBootState.hashCode()
            result = 31 * result + verifiedBootHash.contentHashCode()
            return result
        }

        enum class VerifiedBootState(val intValue: UInt) : Asn1Encodable<Asn1Primitive> {
            Verified(0u),
            SelfSigned(1u),
            Unverified(2u),
            Failed(3u);
            // From: https://source.android.com/docs/security/features/keystore/attestation#schema

            override fun encodeToTlv() =
                Asn1Primitive(BERTags.ENUMERATED, intValue.encodeToAsn1ContentBytes())

            companion object : Asn1Decodable<Asn1Primitive, VerifiedBootState> {
                fun valueOf(int: UInt) = entries.first { it.intValue == int }
                override fun doDecode(src: Asn1Primitive) = src.decodeToEnum<VerifiedBootState>()
            }
        }
    }

    class OsVersion(
        val major: UByte,
        val minor: UByte,
        val sub: UByte
    ) : IntEncodable {
        override val intValue =
            Asn1Integer(sub.toUInt() + minor.toUInt() * 100u + major.toUInt() * 10000u)

        companion object Tag : Tagged(705uL), Asn1Decodable<Asn1Primitive, OsVersion> {
            override fun doDecode(src: Asn1Primitive): OsVersion {
                val raw = Long.decodeFromAsn1ContentBytes(
                    src.decodeToAsn1Integer().encodeToAsn1ContentBytes()
                )
                val sub = raw % 100
                val minor = (raw % 10000) / 100
                val major = raw / 10000
                return OsVersion(major.toUByte(), minor.toUByte(), sub.toUByte())
            }
        }

        override val tagged get() = Tag
        override fun toString(): String {
            return "OsVersion(major=$major, minor=$minor, sub=$sub, intValue=$intValue)"
        }
    }

    class OsPatchLevel(
        val year: UShort,
        val month: Month
    ) : IntEncodable {

        override val intValue = Asn1Integer(month.number.toUInt() + year.toUInt() * 100u)

        companion object Tag : Tagged(706uL), Asn1Decodable<Asn1Primitive, OsPatchLevel> {
            override fun doDecode(src: Asn1Primitive): OsPatchLevel {
                val raw = Long.decodeFromAsn1ContentBytes(
                    src.decodeToAsn1Integer().encodeToAsn1ContentBytes()
                )
                val year = raw / 100
                val month = Month((raw % 100).toInt())
                return OsPatchLevel(year.toUShort(), month)
            }
        }

        override val tagged get() = Tag
        override fun toString(): String {
            return "OsPatchLevel(year=$year, month=$month, intValue=$intValue)"
        }
    }

    /**
     * TODO: encodeSorted beschreiben und erklären warum listen und nicht sets
     * eventuell auch für andrere SETs wie digets padding...
     */
    class AttestationApplicationId internal constructor(
        val packageInfos: List<AttestationPackageInfo>,
        val signatureDigests: List<ByteArray>,
        private val encodeSorted: Boolean
    ) : Asn1Encodable<Asn1Sequence>, Tagged.WithTag<Asn1Sequence> {
        companion object Tag : Tagged(709uL), Asn1Decodable<Asn1Sequence, AttestationApplicationId> {
            override fun doDecode(src: Asn1Sequence) = src.iterator().run {
                AttestationApplicationId(
                    next().asSet().children.map { AttestationPackageInfo.decodeFromTlv(it.asSequence()) },
                    next().asSet().children.map { it.asOctetString().content },
                    encodeSorted = false
                )
            }
        }

        constructor(packageInfos: Set<AttestationPackageInfo>, signatureDigests: Set<ByteArray>)
                : this(packageInfos.toList(), signatureDigests.toList(), encodeSorted = true)

        override val tagged get() = Tag

        override fun encodeToTlv() = Asn1.Sequence {
            if (encodeSorted) {
                +Asn1.SetOf { packageInfos.forEach { +it } }
                +Asn1.SetOf { signatureDigests.forEach { +Asn1.OctetString(it) } }
            } else {
                +Asn1Set.fromPresorted(packageInfos.map { it.encodeToTlv() })
                +Asn1Set.fromPresorted(signatureDigests.map { it.encodeToAsn1OctetStringPrimitive() })
            }
        }

        @OptIn(ExperimentalStdlibApi::class)
        override fun toString(): String {
            return "AttestationApplicationId(packageInfos=${packageInfos}, signatureDigests=${signatureDigests?.map { it.toHexString() }})"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other == null || this::class != other::class) return false

            other as AttestationApplicationId

            if (encodeSorted != other.encodeSorted) return false
            if (packageInfos != other.packageInfos) return false
            if (signatureDigests != other.signatureDigests) return false

            return true
        }

        override fun hashCode(): Int {
            var result = encodeSorted.hashCode()
            result = 31 * result + packageInfos.hashCode()
            result = 31 * result + signatureDigests.hashCode()
            return result
        }


        enum class VerifiedBootState(val intValue: UInt) : Asn1Encodable<Asn1Primitive> {
            Verified(0u),
            SelfSigned(1u),
            Unverified(2u),
            Failed(3u);
            // From: https://source.android.com/docs/security/features/keystore/attestation#schema

            override fun encodeToTlv() =
                Asn1Primitive(BERTags.ENUMERATED, intValue.encodeToAsn1ContentBytes())

            companion object : Asn1Decodable<Asn1Primitive, VerifiedBootState> {
                fun valueOf(int: UInt) = entries.first { it.intValue == int }
                override fun doDecode(src: Asn1Primitive) = src.decodeToEnum<VerifiedBootState>()
            }
        }
    }

    data class AttestationPackageInfo(
        val packageName: String,
        val version: UInt
    ) : Asn1Encodable<Asn1Sequence> {
        companion object :
            Asn1Decodable<Asn1Sequence, AttestationPackageInfo> {
            override fun doDecode(src: Asn1Sequence) = src.iterator().run {
                AttestationPackageInfo(
                    next().asOctetString().content.decodeToString(),
                    next().asPrimitive().decodeToUInt()
                )
            }
        }

        override fun encodeToTlv() = Asn1.Sequence {
            +Asn1.OctetString(packageName.encodeToByteArray())
            +Asn1.Int(version)
        }

        override fun toString(): String {
            return "AttestationPackageInfo(packageName='$packageName', version=$version)"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is AttestationPackageInfo) return false

            if (packageName != other.packageName) return false
            if (version != other.version) return false

            return true
        }

        override fun hashCode(): Int {
            var result = packageName.hashCode()
            result = 31 * result + version.hashCode()
            return result
        }
    }

    sealed class AttestationId(val stringValue: String) : Asn1Encodable<Asn1Primitive>,
        Tagged.WithTag<Asn1Primitive> {
        override fun encodeToTlv() = Asn1.OctetString(stringValue.encodeToByteArray())
        override fun toString(): String {
            return "AttestationId(stringValue='$stringValue')"
        }

        class Brand(name: String) : AttestationId(name) {
            companion object Tag : Tagged(710uL)

            override val tagged get() = Tag
        }

        class Device(name: String) : AttestationId(name) {
            companion object Tag : Tagged(711uL), Asn1Decodable<Asn1Primitive, Device> {
                override fun doDecode(src: Asn1Primitive) =
                    Device(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }

        class Product(name: String) : AttestationId(name) {
            companion object Tag : Tagged(712uL), Asn1Decodable<Asn1Primitive, Product> {
                override fun doDecode(src: Asn1Primitive) =
                    Product(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }

        class Serial(number: String) : AttestationId(number) {
            companion object Tag : Tagged(713uL), Asn1Decodable<Asn1Primitive, Serial> {
                override fun doDecode(src: Asn1Primitive) =
                    Serial(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }

        class Imei(number: String) : AttestationId(number) {
            companion object Tag : Tagged(714uL), Asn1Decodable<Asn1Primitive, Imei> {
                override fun doDecode(src: Asn1Primitive) =
                    Imei(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }

        class Meid(number: String) : AttestationId(number) {
            companion object Tag : Tagged(715uL), Asn1Decodable<Asn1Primitive, Meid> {
                override fun doDecode(src: Asn1Primitive) =
                    Meid(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }

        class Manufacturer(name: String) : AttestationId(name) {
            companion object Tag : Tagged(716uL), Asn1Decodable<Asn1Primitive, Manufacturer> {
                override fun doDecode(src: Asn1Primitive) =
                    Manufacturer(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }

        class Model(name: String) : AttestationId(name) {
            companion object Tag : Tagged(717uL), Asn1Decodable<Asn1Primitive, Model> {
                override fun doDecode(src: Asn1Primitive) =
                    Model(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }

        class SecondImei(number: String) : AttestationId(number) {
            companion object Tag : Tagged(723uL), Asn1Decodable<Asn1Primitive, SecondImei> {
                override fun doDecode(src: Asn1Primitive) =
                    SecondImei(src.asOctetString().content.decodeToString())
            }

            override val tagged get() = Tag
        }
    }

    sealed class PatchLevel(
        val year: UShort,
        val month: Month,
        val day: UShort
    ) : IntEncodable {
        override val intValue =
            Asn1Integer(day.toUInt() + month.number.toUInt() * 100u + year.toUInt() * 10000u)

        companion object {
            fun Asn1Primitive.decode(): Triple<UShort, Month, UShort> {
                val raw = Long.decodeFromAsn1ContentBytes(
                    decodeToAsn1Integer().encodeToAsn1ContentBytes()
                )
                val day = raw % 100
                val monthNumber = (raw % 10000) / 100
                val year = raw / 10000
                return Triple(
                    year.toUShort(),
                    Month(monthNumber.toInt()),
                    day.toUShort()
                )
            }
        }

        class Vendor(
            year: UShort,
            month: Month,
            day: UShort
        ) : PatchLevel(year, month, day) {
            companion object Tag : Tagged(718uL), Asn1Decodable<Asn1Primitive, Vendor> {
                override fun doDecode(src: Asn1Primitive): Vendor = src.decode().let { (y, m, d) ->
                    Vendor(y, m, d)
                }

            }

            override val tagged get() = Tag
        }

        class Boot(
            year: UShort,
            month: Month,
            day: UShort
        ) : PatchLevel(year, month, day) {
            companion object Tag : Tagged(719uL), Asn1Decodable<Asn1Primitive, Boot> {
                override fun doDecode(src: Asn1Primitive): Boot = src.decode().let { (y, m, d) ->
                    Boot(y, m, d)
                }
            }

            override val tagged get() = Tag
        }

        override fun toString(): String {
            return "PatchLevel(year=$year, month=$month, day=$day, intValue=$intValue)"
        }
    }

    /**
     * Can only ever be set by privileged system apps
     */
    object DeviceUniqueAttestation : Tagged(720uL) {
    }


    /**
     * #### Undocumented, ChatGPT-generated! Take with a grain of salt!
     * In the context of Android's Keymaster and Keystore systems, the `moduleHash` is a component within the attestation data structure, specifically in the `KeyDescription` sequence. It provides a cryptographic representation of the software environment associated with the key's creation and usage.
     *
     * **Computation of `moduleHash`:**
     *
     * 1. **Modules Collection:**
     *    - The system gathers a set of `Module` entries, each representing an APEX (Android Pony EXpress) module.
     *    - Each `Module` includes:
     *      - **Package Name (`packageName`):** An octet string identifying the module.
     *      - **Version (`version`):** An integer indicating the module's version at boot time.
     *
     * 2. **DER Encoding:**
     *    - The `Modules` set is encoded using Distinguished Encoding Rules (DER), a binary encoding format for data structures described by ASN.1.
     *    - DER encoding ensures a unique, unambiguous representation of the data, which is crucial for consistent hashing.
     *
     * 3. **Ordering:**
     *    - Within the DER encoding process, the `Module` entries are ordered lexicographically by their encoded value.
     *    - This deterministic ordering guarantees that the same set of modules will always produce the same encoded output, ensuring consistency in the hash computation.
     *
     * 4. **SHA-256 Hashing:**
     *    - The system computes the SHA-256 hash of the DER-encoded `Modules` set.
     *    - The resulting 256-bit hash value is the `moduleHash`.
     *
     * This `moduleHash` serves as a fingerprint of the software environment, allowing verification processes to detect any unauthorized changes to the modules. By including the `moduleHash` in the attestation data, the system provides assurance that the key is used within a trusted and unaltered software environment.
     *
     * For a detailed definition of the `Modules` and `Module` structures, as well as the computation of `moduleHash`, you can refer to the Android Open Source Project's documentation on Keymaster's attestation process.
     */
    class ModuleHash(val sha256Digest: ByteArray) : Asn1Encodable<Asn1Primitive>,
        Tagged.WithTag<Asn1Primitive> {
        override fun encodeToTlv() = Asn1.OctetString(sha256Digest)

        @OptIn(ExperimentalStdlibApi::class)
        override fun toString(): String {
            return "ModuleHash(sha256Digest=${sha256Digest.toHexString()})"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is ModuleHash) return false

            if (!sha256Digest.contentEquals(other.sha256Digest)) return false

            return true
        }

        override fun hashCode(): Int {
            return sha256Digest.contentHashCode()
        }

        companion object Tag : Tagged(724uL), Asn1Decodable<Asn1Primitive, ModuleHash> {
            override fun doDecode(src: Asn1Primitive) = ModuleHash(src.asOctetString().content)
        }

        override val tagged get() = Tag
    }
}
